# 什么是作用域？
几乎所有的编程语言最基本的功能之一，就是能够存储变量当中的值，并且能在之后对这个值进行访问或修改。事实上，正是这种能力将`状态`带给了程序。
但是将变量引入程序会引起几个有意思的问题：
+ 变量存在哪里
+ 程序需要时如何找到变量

这些问题说明需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量。这套规则被称为*作用域*


# 编译原理

+ `词法分析` (lexical analysis): 将由字符组成的字符串分解成词法单元(`token`)
+ `语法分析` (syntax analysis): 将词法单元转换成抽象语法树(`AST`)
+ 代码生成 (code generation): 将抽象语法树转换成机器码

# 词法作用域
`词法作用域就是定义在词法分析阶段的作用域`。换句话说，词法作用域由你在写代码时将变量或块级作用域写在哪里决定的。因此当词法分析时会保持作用域不变

# 作用域分类
+ 全局作用域
+ 函数作用域
+ 块级作用域
  + try/catch
  + let/const
  + {}

# 作用域嵌套
从当前作用域开始查找变量，如果没有找到，则继续向上查找，直到找到或者到达全局作用域。

# 提升
+ var声明的变量和函数声明会被提升到所处作用域的顶部
  + 函数声明会被提升，但是函数表达式不会被提升
+ 每个作用域都会进行提升操作
+ 只有声明本身会被提升，而赋值操作会留在原地
+ 函数提升的优先级高于变量提升

# 闭包
`当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行`
```js
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar
}
foo()(); // 2 bar在它所处的词法作用域之外执行
``` 
```js
function foo() {
    var a = 2;
    function baz() {
        console.log(a);
    }
    bar(baz)
}
function bar(fn) {
    fn(); // 妈妈快看呀，这就是闭包
}
foo();
```
在定时器、事件监听器、Ajax请求、跨窗口通信或任何其它的异步(或同步)任务中，只要使用了`回调函数`,实际上就是在使用闭包
```js
function wait(message) {
    setTimeout(function () {
        console.log(message);
    }, 1000);
}
wait('Hello, closure!');
```
